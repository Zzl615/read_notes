
##  树
#### 定义
树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n(n>0)n(n>0) 个有限节点组成一个具有层次关系的集合。
#### 特点
- 每个节点都只有有限个子节点或无子节点
- 没有父节点的节点称为根节点
- **每一个非根节点有且只有一个父节点**
- 除了根节点外，每个子节点可以分为多个不相交的子树
- **树里面没有环路**

#### 树的遍历
- 前序遍历(pre-order): 根 左 右
- 中序遍历(in-order): 左 根 右
- 后序遍历(post-order): 左 右 根

#### 树组成
父节点、子节点、树高
树结构中的常见用语:
1. 节点的深度：从树的根节点到该节点的边数
2. 节点的高度：该节点和叶子之间最长路径上的边数
3. 树的高度：其根节点的高度

## 二叉搜索树
#### 定义
 二叉查找树（Binary Search Tree -- BST），（又：二叉搜索树，二叉排序树）
 查询效率介于O(log n)~O(n)之间，理想的排序情况下查询效率为O(log n),极端情况下BST就是一个链表结构(如下图)，此时元素查找的效率相等于链表查询O(n)。
#### 特点
- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
  
**二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列**
#### 使用场景
有序地存储数据或者需要同时执行搜索、插入、删除等多步操作，二叉搜索树这个数据结构是一个很好的选择。

#### 平衡二叉搜索树 

1. 每个节点的两个子树的深度不会相差超过1
2. 有N个节点的平衡二搜索叉树的高度总是logN
3. 二叉树的搜索、插入、删除相关操作的时间复杂度中，树的高度是十分重要的考量因素。二叉搜索树的高度总在 logN 到 N 区间变化

### 如何实现一个高度平衡的二叉搜索树?
有许多不同的方法可以实现。尽管这些实现方法的细节有所不同，但他们有相同的目标:
1. 采用的数据结构应该满足二分查找属性和高度平衡属性。
2. 采用的数据结构应该支持二叉搜索树的基本操作，包括在 O(logN) 时间内的搜索、插入和删除，即使在最坏的情况下也是如此。
### 我们提供了一个常见的的高度平衡二叉树列表供您参考：
    - 红黑树
    - AVL树
    - 伸展树
    - 树堆

平衡二叉搜索树的概念经常运用在 Set 和 Map 中。Set 和 Map 的原理相似。 我们将在下文中重点讨论 Set 这个数据结构。

```
   Set（集合）是另一种数据结构，它可以存储大量 key（键）而不需要任何特定的顺序或任何重复的元素。 它应该支持的基本操作是将新元素插入到 Set 中，并检查元素是否存在于其中。
```

通常，有两种最广泛使用的集合：散列集合（Hash Set）和 树集合（Tree Set）。

1. 树集合，Java 中的 Treeset 或者 C++ 中的 set ，是由高度平衡的二叉搜索树实现的。因此，搜索、插入和删除的时间复杂度都是 O(logN) 。

2. 散列集合，Java 中的 HashSet 或者 C++ 中的 unordered_set ，是由哈希实现的，但是平衡二叉搜索树也起到了至关重要的作用。当存在具有相同哈希键的元素过多时，将花费 O(N) 时间复杂度来查找特定元素，其中N是具有相同哈希键的元素的数量。 通常情况下，使用高度平衡的二叉搜索树将把时间复杂度从 O(N) 改善到 O(logN) 。

3. 哈希集和树集之间的本质区别在于树集中的键是有序的。

